# 操作系统

   如需要展开全部,可以在网页控制台执行以下代码
   ```
   [...document.getElementById("readme").getElementsByTagName("details")].forEach(e => e.open = true)
   ```

* [TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？](#1)

* [简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？](#2)

* [TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？](#3)

* [TCP 怎么保证可靠传输？](#4)

* [简述 TCP 滑动窗口以及拥塞控制？](#5)

* [什么是 TCP 粘包和拆包？](#6)

* [TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？](#7)

* [RestFul 是什么？RestFul 请求的 URL 有什么特点？](#8)

* [Session与Cookie的区别？](#9)

* [从输入网址到获得页面的过程?](#10)

* [HTTP 与 HTTPS 有哪些区别？](#11)

* [简述 HTTP 1.0，1.1，2.0 的主要区别 ?](#12)

* [HTTP 中 GET 和 POST 区别 ?](#13)

* [简述常见的 HTTP 状态码的含义（301，304，401，403）?](#14)

* [简述对称与非对称加密的概念?](#15)

* [简述 HTTPS 的加密与认证过程?](#16)

* [简述 HTTP 短链接与长链接的区别?](#17)



------

### <span id="1">1.TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</span>
<details>
<summary>展开</summary>
TCP和UDP都是传输层的协议

### TCP与UDP的区别
区别：
1. TCP是面向连接的，UDP是无连接的；
    * UDP发送数据之前不需要建立连接
2. TCP是可靠的，UDP不可靠；
    * UDP接收方收到报文后，不需要给出任何确认
3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
4. TCP是面向字节流的，UDP是面向报文的；
    * 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
5. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低。


### 什么时候选择TCP，什么时候选UDP？
对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失

### HTTP可以使用UDP吗？
HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠。
http 3.0 使用udp实现，但HTTP/3仍然是草案状态

### 面向连接和无连接的区别
面向连接，是指通信双方在进行通信之前，要事先在双方之间建立起一个完整的可以彼此沟通的通道，这个通道也就是连接。在通信过程中，整个连接的情况一直可以被实时地监控和管理。
而无连接的通信，就不需要预先建立起一个联络两个通信节点的连接来，需要通信的时候，发送节点就可以往“网络”上送出信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控，让该信息的传递在通信网络中尽力而为地往目的地节点传送。

### UDP如何实现可靠传输呢？
传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
详细步骤：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。

用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。


</details>


------

### <span id="2">简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</span>
<details>
<summary>展开</summary>


### TCP标志位
```
SYN（synchronous）： 发送/同步标志，用来建立连接，和 ACK 标志位搭配使用。A 请求与 B 建立连接时，SYN=1，ACK=0；B 确认与 A 建立连接时，SYN=1，ACK=1
ACK（acknowledgement）：确认标志，表示确认收到请求
PSH（push） ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理
FIN（finish）：结束标志，表示关闭一个 TCP 连接
RST（reset）：重置复位标志，用于复位对应的 TCP 连接
URG（urgent）：紧急标志，用于保证 TCP 连接不被中断，并且督促中间层设备尽快处理
```

### TCP三次握手

![](https://github.com/binbinshan/Review-Up/blob/master/images/网络协议/16243327291797.jpg)

1. 第一次握手：Clien 发送 SYN=1 和 一个随机产生的Client初始序列号 seq 到 Server。

2. 第二次握手：Server 收到 SYN=1 后，知道客户端请求建立连接，发送 SYN=1 , ACK=1 和 ack number (Client 发送的seq + 1) 和一个随机产生的 Server 初始序列号 seq 发送给 Client。
3. 第三次握手：Client检查接收的 ack number 是不是 自己发送的 Client seq + 1 并且 SYN=1，检查通过后发送 ACK=1 和 ack number（Server 发送的 seq+1），发送给服务器；服务器检查通过后，连接建立。


### 为什么需要TCP三次握手？
从大的方面来讲的话，就是确保双方都可以 正常的发送和接收，可以建立可靠的连接。
从细的方面来说，就是通过三次握手才可以 初始化Socket、序列号 以及 初始化窗口大小。

### TCP非得三次握手才行吗？
先说结论，三个方面：
1. 通过三次握手才能阻止重复历史连接的初始化；
2. 通过三次握手才能对通信双方的初始序列号进行初始化；
3. 大于三次的握手没有必要；

结论1：
如果只有两次握手，在网络状况复杂的情况下，发送方连续发送多次建立连接的请求，此时就无法区分历史请求，就会来建立垃圾请求，那么三次握手时，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接，阻止建立重复连接。

结论2：
TCP作为一个可靠的传输协议，要达到可靠就要通过**序列号**对数据包**去重、排序、未ACK重发** 。所以连接通信的双方都需要获得初始序列号，因此它们其实需要向对方发送 SYN 消息并携带自己的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。 

结论3：
目的是更少的通信次数（理论上的边界）完成信息的交换，所以三次握手是最少次数。
四次握手指的是将第二次握手时发送 SYN消息 和 发送初始化序号SEQ 拆开发送，但这个是没必要的，可以合并成一次发送。


### 第三次握手，如果客户端的ACK未送达服务器，会怎样？
分客户端和服务端分析：

* 服务端：如果服务端没有收到客户端的ACK，那么就会重发SYN+ACK(默认发送5次，之后就会进入Closed状态);

* 客户端：
    1. 在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ack number ,然后建立连接
    2. 在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。

### TCP四次挥手

![](https://github.com/binbinshan/Review-Up/blob/master/images/网络协议/16243422463128.jpg)
* 第一次挥手：Client将 FIN = 1 和 一个随机序列号 seq 发送给Server。

* 第二次挥手：Server收到 FIN 之后，发送一个 ACK=1 和 ack number(client seq + 1)，此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据，服务器进入CLOSE-WAIT状态。

* 第三次挥手：server处理完自己的事情后，将 FIN = 1 和 一个新的随机序列号 seq 给 Client；。

* 第四次挥手：，Client 收到服务器的 FIN 后，进入 TIME_WAIT 状态，将 ACK = 1 和 ack number(Server序列号+1) 发送给服务器；
    * 服务器收到后，确认ack number后，变为 CLOSED 状态，不再向客户端发送数据。客户端等待 2 * MSL（报文段最长寿命）时间后，也进入 CLOSED 状态。完成四次挥手。

### 为什么需要TCP四次挥手？
因为 TCP 是全双工的，一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。

### 如果已经建立了连接，但是客户端出现故障了怎么办？
简而言之，通过定时器 + 超时重试机制，
具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。

### 客户端TIME_WAIT状态的意义是什么？
第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。
如果Server没有收到ACK，就会重发FIN

* 如果Client在 2 * MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发FIN。
* 如果Client在 2 * MSL 的时间内没有收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

</details>


------

### <span id="3">3.TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？</span>
<details>
<summary>展开</summary>


服务器收到客户端的关闭请求后，会将状态设置为CLOSE_WAIT, 就是为了保证服务器在关闭连接之前将待发送的数据发送完成。

出现大量CLOSE_WAIT时，需要看是不是代码中服务端程序忘记关闭连接。


TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态。
若没有该状态机会才出现一下问题：
1. 服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包
2. 由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，那么当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生。


</details>


------

### <span id="4">4.TCP 怎么保证可靠传输？</span>
<details>
<summary>展开</summary>

1. 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

3. TCP 的接收端会丢弃重复的数据。
4. 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
5. 拥塞控制： 当网络拥塞时，减少数据的发送。
6. ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
7. 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

</details>


------

### <span id="5">5.简述 TCP 滑动窗口以及拥塞控制？</span>
<details>
<summary>展开</summary>

TCP 实现流量控制的关键是滑动窗口（Sliding Window）。发送端和接收端均有一个滑动窗口，对应一个缓冲区，记录当前发送或接收到的数据。接收端会在返回的 ACK 报文中包含自己可用于接收数据的缓冲区的大小，在 TCP 的报文首部里用 window 表示（或者叫 AdvertisedWindow，16 bit，最多 65535 字节）。发送端发送的数据不会超过 window 的大小。

### 零窗口
如果接收端处理过慢，那么 window 可能变为 0，这种情况下发送端就不再发送数据了。如何在接收端 window 可用的时候通知发送端呢？

TCP 使用来 ZWP（Zero Window Probe，零窗口探针）技术。具体是在发送端引入一个计时器，每当收到一个零窗口的应答后就启动该计时器。每间隔一段时间就主动发送报文，由接收端来 ACK 窗口大小。若接收者持续返回零窗口（一般是 3 次），则有的 TCP 实现会发送 RST 断开连接。

### 拥塞控制
当等待接收端的 ACK 超时、或者收到乱序包时，说明网络出现了拥塞。TCP 通过各种协同工作的机制来解决网络拥塞。

发送端维持一个叫做拥塞窗口 cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。下面用报文段个数作为 cwnd 的值进行说明，实际的 cwnd 是以字节为单位的。

##### 慢启动
1. 连接建立时，初始化 cwnd = 1，表示可以传 1个 MSS 大小的数据
2. 每收到一个 ACK 包，cwnd++
3. 每经过一个 RTT(一个往返时间)，cwnd 会翻倍（指数增长）

##### 拥塞避免
1. 当 cwnd >= ssthresh (慢开始阈值) 时，进入拥塞避免阶段。
2. 每经过一个 RTT，cwnd = cwnd + 1（线性增加）

##### 超时重传
如果发送端超时还未收到 ACK 包，就可以认为网络出现了拥塞，需要解决拥塞：

1. 把 sshthresh(慢开始阈值) 设为原来的一半
2. cwnd 重置为 1，重新开始慢启动过程


##### 快速重传 / 快速恢复
快速重传：接收端收到乱序包时，会发送 「重复确认」 通知发送端。当发送端收到 3 个 「重复确认」时，就立刻开始重传，而不必继续等待到计时器超时。快速重传会配合快速恢复算法：

1. 把 sshthresh(慢开始阈值) 设为原来的一半
2. cwnd 重置为 sshthresh，重新开始拥塞避免过程

###### 为什么快速重传不需要像超时重传那样，将 cwnd 重置为 1 重新开始慢启动呢？
因为它认为如果网络出现拥塞的话，是不会收到好几个重复的 ACK 的，所以现在网络可能没有出现拥塞。


总结：流量控制是接收端控制的，拥塞避免是发送端控制的。最终都是控制发送端的发送速率。

</details>


------

### <span id="6">6.什么是 TCP 粘包和拆包？</span>
<details>
<summary>展开</summary>

TCP 是基于字节流的，数据块是没有边界、没有结构的字节流，因此可能产生粘包：

1. 发送方为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包一次性发送。
2. 接收方不能及时读取数据，导致缓冲区中的多个包粘连。

常见解决方法

1. 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。

2. 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。

3. 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。



### 为什么 UDP 协议没有粘包问题？
UDP 是面向报文的，应用层交给 UDP 多长的报文，UDP 就照样发送，既不合并，也不拆分，而是保留这些报文的边界。

</details>

------

### <span id="7">7.TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</span>
<details>
<summary>展开</summary>

* HTTP协议的Keep-Alive意图在于连接复用，同一个连接上串行方式传递请求-响应数据。

* TCP的KeepAlive机制意图在于保活、心跳，检测连接错误，通过发送一个空的报文，去确认服务端是否存活。

</details>



------

### <span id="8">8.RestFul 是什么？RestFul 请求的 URL 有什么特点？</span>
<details>
<summary>展开</summary>

RestFul 是表现层状态转化，通俗的来讲就是 “资源”在网络传输中以某种“表现形式”进行“状态转移” 。

资源：可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源

表现形式：资源"是一种信息实体，它可以有多种外在表现形式。我们把"资源"具体呈现出来的形式比如 json，xml，image,txt 等等叫做它的"表现层/表现形式"。

状态转移：比如你通过增删改查（PUT、DELETE、GET、POST）引起资源状态的改变

总结：
1. 每一个 URI 代表一种资源；
2. 客户端和服务器之间，传递这种资源的某种表现形式比如 json，xml，image,txt 等等；
3. 客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现"表现层状态转化"。

规范：
1. 不能有动词，只能有名词，API 中的名词也应该使用复数
2. 不用大写字母，建议用中杠 - 不用下杠 _ 
3. 多用版本号，比如 /xxxxx/v1/xxx

</details>



------

### <span id="9">9.Session与Cookie的区别？</span>
<details>
<summary>展开</summary>

二者都是用来跟踪浏览器用户身份的会话方式。

* Cookie：
    * 存在浏览器里，可以设置过期时间
    * 每次访问服务器时，浏览器会自动在 header 中携带 cookie
    * 如果浏览器禁用了 cookie，可以使用 URL 重写机制，将信息保存在 URL 里

* Session:
    * 存在服务端，由服务器维护，一段时间后 session 就失效了
    * 本质上，session 还是通过 cookie 实现的。浏览器的 cookie 中只保存一个 sessionId，所有其他信息均保存在服务端，由 sessionId 标识
    * Session 失效，其实是服务器设置了失效时间。如果用户长时间不和服务器交互（比如 30 分钟），那么 session 就会被销毁；交互的话，就会刷新 session

</details>


------

### <span id="10">10.从输入网址到获得页面的过程?</span>
<details>
<summary>展开</summary>

<img src="https://github.com/binbinshan/Review-Up/blob/master/images/网络协议/16244383253259.jpg" width = "1160" height = "914" alt="" align=center />

</details>

------

### <span id="11">11.HTTP 与 HTTPS 有哪些区别？</span>
<details>
<summary>展开</summary>

1. HTTP使用80端口，HTTPS使用443端口。
2. HTTP是不安全的，HTTPS是安全的。
3. HTTP信息是明文传输，HTTPS运行在SSL/TSL之上，添加了加密和认证机制，更加安全；
4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买
5. HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。

-----
HTTP：超文本传输协议，是基于TCP的应用层协议，它是允许客户端与网站进行通信。客户端向网站的 HTTP 服务器（在 TCP 三次握手之后）发送请求消息，然后服务器回复响应消息。在服务器返回的消息中包括完成状态信息，例如HTTP/1.1 200 OK

-----
HTTPS:安全超文本传输协议，HTTPS也是基于HTTP的，只是在HTTP内容向下传输的时候加了一层TLS/SSL加密。
<img src="https://github.com/binbinshan/Review-Up/blob/master/images/网络协议/16244172364045.jpg" width = "256" height = "278" alt="" align=center />

</details>
------

### <span id="12">12.简述 HTTP 1.0，1.1，2.0 的主要区别 ?</span>
<details>
<summary>展开</summary>

1. 长连接：1.0需要使用keep-alive 参数来告知服务端建立一个长连接；1.1、2.0默认支持。
2. host域：1.0不支持；1.1、2.0支持。
3. 多路复用：1.0 不支持多路复用；2.0支持多路复用。
4. 数据压缩：1.0、1.1不支持数据压缩；2.0使用HAPCK算法对header数据进行压缩，使数据体积变小，传输更快。
5. 服务器推送：1.0、1.1不支持服务器推送；2.0支持服务器推送

</details>
------

### <span id="13">13.HTTP 中 GET 和 POST 区别 ?</span>
<details>
<summary>展开</summary>

HTTP中的请求方法代表了对给定资源的执行的操作，每个请求的方法都有不同的语义，几种常见的请求方法：
* GET：一个幂等、安全的HTTP方法，用于获取指定资源。
* POST：一个非幂等、不安全的方法，用于提交资源到服务器或者在服务器新建资源。
* DELETE：一个幂等、不安全的方法，用于删除服务器指定资源。
* PUT：：一个幂等、不安全的方法，替换整个目标资源。

----- 
幂等的：一个 HTTP 方法是幂等的，指的是同样的请求执行一次与执行多次的效果是一样的。换句话说就是，幂等方法不应该具有副作用。

安全的：一个 HTTP 方法是安全的，指的是这是一个对服务器只读操作的方法，不会修改服务器数据。

### GET和POST的区别
1. GET是幂等的，POST不是幂等的；
2. GET是对服务器资源的获取，POST 会对服务器资源进行修改。
3. GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；
4. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制


</details>
------

### <span id="14">14.简述常见的 HTTP 状态码的含义（301，304，401，403）?</span>
<details>
<summary>展开</summary>

在客户端请求HTTP服务器后，服务器会回复消息表示请求状态，常见状态码：

1. 2xx状态码：操作成功。200 OK
2. 3xx状态码：重定向。301 永久重定向；302暂时重定向
3. 4xx状态码：客户端错误。401 未授权；403 被禁止的；404 未找到页面；
4. 5xx状态码：服务端错误。500服务器内部错误；501服务不可用


</details>

------

### <span id="15">15.简述对称与非对称加密的概念?</span>
<details>
<summary>展开</summary>

### 什么是加密？
因为http的内容是明文传输的，在经过多个物理节点，如果在这期间数据被劫持，传输的内容就会泄露，劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。

### 什么是对称加密？
简单说只有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多。
问题：在进行秘钥传输的时候，还是会有被劫持的风险。

### 什么是非对称加密？
简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。

### 非对称加密的问题
* 保证了浏览器到服务器的安全
服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，只有服务器有相应的私钥能解开公钥加密的数据。

* 无法保证服务器到浏览器的安全性
如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。

### 使用 非对称加密+对称加密结合
1. 网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥A’解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

### 中间人攻击
上面讨论 非对称加密+对称加密结合的方式，看似没有问题了，实则还是会出现中间人攻击，那什么是中间人攻击呢？
1. 网站有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. （被劫持）中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。
4. 浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。
5. （被劫持）中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。
6. 服务器拿到后用私钥A’解密得到密钥X。



</details>
------

### <span id="16">16.简述 HTTPS 的加密与认证过程?</span>
<details>
<summary>展开</summary>

HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。

</details>
------

### <span id="17">17.简述 HTTP 短链接与长链接的区别?</span>
<details>
<summary>展开</summary>

HTTP/1.0 默认使用的是短连接。也就是说，浏览器每请求一个静态资源，就建立一次连接，任务结束就中断连接。

HTTP/1.1 默认使用的是长连接。长连接是指在一个网页打开期间，所有网络请求都使用同一条已经建立的连接。当没有数据发送时，双方需要发检测包以维持此连接。长连接不会永久保持连接，而是有一个保持时间。实现长连接要客户端和服务端都支持长连接。

长连接的优点：TCP 三次握手时会有 1.5 RTT 的延迟，以及建立连接后慢启动（slow-start）特性，当请求频繁时，建立和关闭 TCP 连接会浪费时间和带宽，而重用一条已有的连接性能更好。

长连接的缺点：长连接会占用服务器的资源。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。

</details>








