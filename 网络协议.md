# 操作系统

   如需要展开全部,可以在网页控制台执行以下代码
   ```
   [...document.getElementById("readme").getElementsByTagName("details")].forEach(e => e.open = true)
   ```

* [TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？](#1)

* [简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？](#2)

* [TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？](#3)

* [TCP 怎么保证可靠传输？](#4)

* [简述 TCP 滑动窗口以及拥塞控制？](#5)

* [什么是 TCP 粘包和拆包？](#6)

* [TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？](#7)




------

### <span id="1">1.TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</span>
<details>
<summary>展开</summary>
TCP和UDP都是传输层的协议

### TCP与UDP的区别
区别：
1. TCP是面向连接的，UDP是无连接的；
    * UDP发送数据之前不需要建立连接
2. TCP是可靠的，UDP不可靠；
    * UDP接收方收到报文后，不需要给出任何确认
3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
4. TCP是面向字节流的，UDP是面向报文的；
    * 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
5. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低。


### 什么时候选择TCP，什么时候选UDP？
对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失

### HTTP可以使用UDP吗？
HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠。
http 3.0 使用udp实现，但HTTP/3仍然是草案状态

### 面向连接和无连接的区别
面向连接，是指通信双方在进行通信之前，要事先在双方之间建立起一个完整的可以彼此沟通的通道，这个通道也就是连接。在通信过程中，整个连接的情况一直可以被实时地监控和管理。
而无连接的通信，就不需要预先建立起一个联络两个通信节点的连接来，需要通信的时候，发送节点就可以往“网络”上送出信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控，让该信息的传递在通信网络中尽力而为地往目的地节点传送。

### UDP如何实现可靠传输呢？
传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
详细步骤：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。

用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。


</details>


------

### <span id="2">简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</span>
<details>
<summary>展开</summary>


### 0. TCP标志位
```
SYN（synchronous）： 发送/同步标志，用来建立连接，和 ACK 标志位搭配使用。A 请求与 B 建立连接时，SYN=1，ACK=0；B 确认与 A 建立连接时，SYN=1，ACK=1
ACK（acknowledgement）：确认标志，表示确认收到请求
PSH（push） ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理
FIN（finish）：结束标志，表示关闭一个 TCP 连接
RST（reset）：重置复位标志，用于复位对应的 TCP 连接
URG（urgent）：紧急标志，用于保证 TCP 连接不被中断，并且督促中间层设备尽快处理
```

### 1. TCP三次握手

![](https://github.com/binbinshan/Review-Up/blob/master/images/网络协议/16243327291797.jpg)

1. 第一次握手：Clien 发送 SYN=1 和 一个随机产生的Client初始序列号 seq 到 Server。

2. 第二次握手：Server 收到 SYN=1 后，知道客户端请求建立连接，发送 SYN=1 , ACK=1 和 ack number (Client 发送的seq + 1) 和一个随机产生的 Server 初始序列号 seq 发送给 Client。
3. 第三次握手：Client检查接收的 ack number 是不是 自己发送的 Client seq + 1 并且 SYN=1，检查通过后发送 ACK=1 和 ack number（Server 发送的 seq+1），发送给服务器；服务器检查通过后，连接建立。


### 2. 为什么需要TCP三次握手？
从大的方面来讲的话，就是确保双方都可以 正常的发送和接收，可以建立可靠的连接。
从细的方面来说，就是通过三次握手才可以 初始化Socket、序列号 以及 初始化窗口大小。

### 3. TCP非得三次握手才行吗？
先说结论，三个方面：
1. 通过三次握手才能阻止重复历史连接的初始化；
2. 通过三次握手才能对通信双方的初始序列号进行初始化；
3. 大于三次的握手没有必要；

结论1：
如果只有两次握手，在网络状况复杂的情况下，发送方连续发送多次建立连接的请求，此时就无法区分历史请求，就会来建立垃圾请求，那么三次握手时，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接，阻止建立重复连接。

结论2：
TCP作为一个可靠的传输协议，要达到可靠就要通过**序列号**对数据包**去重、排序、未ACK重发** 。所以连接通信的双方都需要获得初始序列号，因此它们其实需要向对方发送 SYN 消息并携带自己的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。 

结论3：
目的是更少的通信次数（理论上的边界）完成信息的交换，所以三次握手是最少次数。
四次握手指的是将第二次握手时发送 SYN消息 和 发送初始化序号SEQ 拆开发送，但这个是没必要的，可以合并成一次发送。


### 4. 第三次握手，如果客户端的ACK未送达服务器，会怎样？
分客户端和服务端分析：

* 服务端：如果服务端没有收到客户端的ACK，那么就会重发SYN+ACK(默认发送5次，之后就会进入Closed状态);

* 客户端：
    1. 在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ack number ,然后建立连接
    2. 在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。

### 5. TCP四次挥手

![](https://github.com/binbinshan/Review-Up/blob/master/images/网络协议/16243422463128.jpg)
* 第一次挥手：Client将 FIN = 1 和 一个随机序列号 seq 发送给Server。

* 第二次挥手：Server收到 FIN 之后，发送一个 ACK=1 和 ack number(client seq + 1)，此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据，服务器进入CLOSE-WAIT状态。

* 第三次挥手：server处理完自己的事情后，将 FIN = 1 和 一个新的随机序列号 seq 给 Client；。

* 第四次挥手：，Client 收到服务器的 FIN 后，进入 TIME_WAIT 状态，将 ACK = 1 和 ack number(Server序列号+1) 发送给服务器；
    * 服务器收到后，确认ack number后，变为 CLOSED 状态，不再向客户端发送数据。客户端等待 2 * MSL（报文段最长寿命）时间后，也进入 CLOSED 状态。完成四次挥手。

### 6. 为什么需要TCP四次挥手？
因为 TCP 是全双工的，一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。

### 7. 如果已经建立了连接，但是客户端出现故障了怎么办？
简而言之，通过定时器 + 超时重试机制，
具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。

### 8. 客户端TIME_WAIT状态的意义是什么？
第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。
如果Server没有收到ACK，就会重发FIN

* 如果Client在 2 * MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发FIN。
* 如果Client在 2 * MSL 的时间内没有收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

</details>


------

### <span id="3">3.TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？</span>
<details>
<summary>展开</summary>


服务器收到客户端的关闭请求后，会将状态设置为CLOSE_WAIT, 就是为了保证服务器在关闭连接之前将待发送的数据发送完成。

出现大量CLOSE_WAIT时，需要看是不是代码中服务端程序忘记关闭连接。


TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态。
若没有该状态机会才出现一下问题：
1. 服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包
2. 由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，那么当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生。


</details>


------

### <span id="4">4.TCP 怎么保证可靠传输？</span>
<details>
<summary>展开</summary>

1. 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

3. TCP 的接收端会丢弃重复的数据。
4. 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
5. 拥塞控制： 当网络拥塞时，减少数据的发送。
6. ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
7. 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

</details>


------

### <span id="5">5.简述 TCP 滑动窗口以及拥塞控制？</span>
<details>
<summary>展开</summary>

TCP 实现流量控制的关键是滑动窗口（Sliding Window）。发送端和接收端均有一个滑动窗口，对应一个缓冲区，记录当前发送或接收到的数据。接收端会在返回的 ACK 报文中包含自己可用于接收数据的缓冲区的大小，在 TCP 的报文首部里用 window 表示（或者叫 AdvertisedWindow，16 bit，最多 65535 字节）。发送端发送的数据不会超过 window 的大小。

### 零窗口
如果接收端处理过慢，那么 window 可能变为 0，这种情况下发送端就不再发送数据了。如何在接收端 window 可用的时候通知发送端呢？

TCP 使用来 ZWP（Zero Window Probe，零窗口探针）技术。具体是在发送端引入一个计时器，每当收到一个零窗口的应答后就启动该计时器。每间隔一段时间就主动发送报文，由接收端来 ACK 窗口大小。若接收者持续返回零窗口（一般是 3 次），则有的 TCP 实现会发送 RST 断开连接。

### 拥塞控制
当等待接收端的 ACK 超时、或者收到乱序包时，说明网络出现了拥塞。TCP 通过各种协同工作的机制来解决网络拥塞。

发送端维持一个叫做拥塞窗口 cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。下面用报文段个数作为 cwnd 的值进行说明，实际的 cwnd 是以字节为单位的。

##### 慢启动
1. 连接建立时，初始化 cwnd = 1，表示可以传 1个 MSS 大小的数据
2. 每收到一个 ACK 包，cwnd++
3. 每经过一个 RTT(一个往返时间)，cwnd 会翻倍（指数增长）

##### 拥塞避免
1. 当 cwnd >= ssthresh (慢开始阈值) 时，进入拥塞避免阶段。
2. 每经过一个 RTT，cwnd = cwnd + 1（线性增加）

##### 超时重传
如果发送端超时还未收到 ACK 包，就可以认为网络出现了拥塞，需要解决拥塞：

1. 把 sshthresh(慢开始阈值) 设为原来的一半
2. cwnd 重置为 1，重新开始慢启动过程


##### 快速重传 / 快速恢复
快速重传：接收端收到乱序包时，会发送 「重复确认」 通知发送端。当发送端收到 3 个 「重复确认」时，就立刻开始重传，而不必继续等待到计时器超时。快速重传会配合快速恢复算法：

1. 把 sshthresh(慢开始阈值) 设为原来的一半
2. cwnd 重置为 sshthresh，重新开始拥塞避免过程

###### 为什么快速重传不需要像超时重传那样，将 cwnd 重置为 1 重新开始慢启动呢？
因为它认为如果网络出现拥塞的话，是不会收到好几个重复的 ACK 的，所以现在网络可能没有出现拥塞。


总结：流量控制是接收端控制的，拥塞避免是发送端控制的。最终都是控制发送端的发送速率。

</details>


------

### <span id="6">6.什么是 TCP 粘包和拆包？</span>
<details>
<summary>展开</summary>

TCP 是基于字节流的，数据块是没有边界、没有结构的字节流，因此可能产生粘包：

1. 发送方为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包一次性发送。
2. 接收方不能及时读取数据，导致缓冲区中的多个包粘连。

常见解决方法

1. 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。

2. 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。

3. 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。



### 为什么 UDP 协议没有粘包问题？
UDP 是面向报文的，应用层交给 UDP 多长的报文，UDP 就照样发送，既不合并，也不拆分，而是保留这些报文的边界。

</details>
------

### <span id="7">7.TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</span>
<details>
<summary>展开</summary>

* HTTP协议的Keep-Alive意图在于连接复用，同一个连接上串行方式传递请求-响应数据。

* TCP的KeepAlive机制意图在于保活、心跳，检测连接错误，通过发送一个空的报文，去确认服务端是否存活。

</details>