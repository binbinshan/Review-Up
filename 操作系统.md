# 操作系统


* [简述 Linux 内核态与用户态，什么时候会进入内核态？](#1)

* [什么是文件描述符？](#2)

* [简述 Linux 的 I/O模型？](#3)

* [简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？](#4)


------

### <span id="1">1.简述 Linux 内核态与用户态，什么时候会进入内核态？</span>
回答这道题的前提，需要先了解几个概念：虚拟地址空间和寻址、 内核空间和用户空间、内核态和用户态。
##### 虚拟地址空间和寻址
<details>
<summary>展开</summary>
以32位操作系统为例，它的寻址空间就是4G(2^32)。

寻址是指操作系统能找到的地址范围，32位的操作系统能找到的最大地址空间就是4G。
操作系统会给每个进程分配4G的虚拟内存空间，这个虚拟内存空间和真实内存空间之间有映射关系。
</details>

##### 内核空间和用户空间
<details>
<summary>展开</summary>
现代操作系统都会有内核，内核可以访问受保护的内存空间和访问底层硬件的权限，所以为了保证内核空间的安全。就需要区分内核空间和用户空间。
所以以4G的地址空间为例，内核空间拥有最上面的 1G 空间，用户空间拥有其余的3G空间。最高 1G 的内核空间是被所有进程共享的。

![](https://github.com/binbinshan/Review-Up/blob/master/images/网络协议/16239276614333.jpg)

也就是每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。 
</details>

##### 内核态和用户态
<details>
<summary>展开</summary>
在理解了内核空间和用户空间之后，内核态和用户态就非常简单了。当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。

* 在内核态中，进程运行在内核空间中，此时CPU可以执行任何指令，运行代码也不受限制，可以访问任意内存空间。
* 在用户态中，进程运行在用户空间中，此时要受制CPU的各种限制，也只能访问用户态下可访问的虚拟空间地址。
</details>

##### 用户态怎么陷入内核态？
<details>
<summary>展开</summary>
主要是三个方面，会使用户态陷入内核态：

1. 系统调用：用户态进程通过系统调用申请使用操作系统提供的服务来完成任务，比如说读取磁盘上的一个文件，就会将用户态进程转为内核态。

2. 异常：当进程在用户态的执行过程中出现异常，此时就会由当前进程切换到内核中处理异常的服务中，也会将用户态进程转为内核态。
3. 外围设备中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，比如说读取磁盘文件完成，系统会切换到中断处理后的后续操作，这个时候如果执行指令的进程处于用户态时，也会先切入到内核态。
</details>


------

### <span id="2">2.什么是文件描述符？</span>
<details>
<summary>展开</summary>

文件描述符是一个非负整数，从0开始。进程使用文件描述符来标识一个打开的文件。

系统为每个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而**文件描述符**实际上就是这张表的索引。当进程打开（open）或者新建（create）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。

一般来说，每个进程最多可以打开 64 个文件，fd ∈ 0~63。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。

每个进程默认都有 3 个文件描述符：0 (stdin)、1 (stdout)、2 (stderr)。分别代表：标准输入流、标准输出流、标准错误流。

##### socket和fd

socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 socket() 函数创建。

比如可以将 socket 和 fd 视为同义词，当我们获取了一个socket,返回的就是这个 socket 对应的文件描述符 fd。操作系统将 socket 映射到进程的一个文件描述符上，进程就可以通过读写这个文件描述符来和远程主机通信。

socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现。socket 与 fd 是一一对应的。通过 socket 通信，实际上就是通过文件描述符 fd 读写文件。这也符合 Unix“一切皆文件”的哲学。

</details>


------

### <span id="3">3.简述 Linux 的 I/O模型</span>
<details>
<summary>展开</summary>

网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。

对于一次IO的read来说分为两步：
1. 等待数据准备
2. 将数据从内核拷贝到进程

对于socket流而言：
1. 通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。
2. 把数据从内核缓冲区复制到应用进程缓冲区。

----
网络IO模型有以下几种：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO

* 阻塞IO：socket默认IO模型，进程从用户调用到系统调用，再到读取数据，所有中间过程中进程都是阻塞的，直到数据读取完毕。

![](https://github.com/binbinshan/Review-Up/blob/master/images/操作系统/16240019257667.jpg)
优点：能够无延迟的返回数据，即处理完即可返回。
缺点：进程会阻塞，导致性能变低。


* 非阻塞IO：应用进程执行系统调用之后，内核会返回一个错误码。应用进程不阻塞可以继续执行，但是需要不断的执行系统调用来获知是否完成，这种方式称为轮询(polling)。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。

![](https://github.com/binbinshan/Review-Up/blob/master/images/操作系统/16240025876184.jpg)
优点：进程在等待的时候，可以进行其他任务。
缺点：因为轮询的原因，任务的响应延迟会增大。

* 多路复用IO：使用 select、poll、epoll函数 让多个进程阻塞在这里，当任意一个数据准备好之后，返回进行可读，然后进程再进行系统调用，将数据由内核拷贝到用户进程。

多路复用IO相对于非阻塞IO：前者可以等待多个socket，能实现同时对多个IO端口进行监听。后者只能对一个进程进行轮询。

![](https://github.com/binbinshan/Review-Up/blob/master/images/操作系统/16240046660747.jpg)
优点：系统开销小，系统不需要创建新的额外进程或者线程
缺点：
前三种IO模型，从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型。都是进程主动等待且向内核检查状态。
高并发的程序一般使用 同步非阻塞 方式而非 多线程 + 同步阻塞方式

* 信号驱动IO：首先允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

![](https://github.com/binbinshan/Review-Up/blob/master/images/操作系统/16240063938595.jpg)

* 异步非阻塞IO：用户进程进行系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。

![](https://github.com/binbinshan/Review-Up/blob/master/images/操作系统/16240064759583.jpg)


五种IO比较：

![](https://github.com/binbinshan/Review-Up/blob/master/images/操作系统/16240065655489.jpg)

非阻塞IO和异步IO的区别：
非阻塞IO是同步的，而异步IO是异步的，这是因为非阻塞IO要不断的去轮询检查是否数据读取完成，而异步IO会在数据读完之后直接从内核拷贝到用户空间。

</details>


------

### <span id="4">4.简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？</span>
<details>
<summary>展开</summary>
select、poll、epoll都是I/O多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个文件描述符，一旦某个描述符就绪（读就绪或写就绪），能够通知程序进行相应的读写操作 。

### select 
使用fd_set(文件描述符集合)，将感兴趣的文件描述符传给select，select会将就绪的文件描述符返回。通知进行读写。

缺点：
1. 用户态和内核态的频繁切换：当需要select监听一个文件描述符时，就会把fd_set从用户态拷贝到内核态。
2. 内核需要遍历传进来的每一个文件描述符，不管是否就绪。
3. 监听的文件描述符数量受限制，最多1024个，不同操作系统可能不同。

### poll
poll 和 select 几乎没有区别。poll 采用链表的方式存储文件描述符，没有最大存储数量的限制。

缺点和select基本一样，除了文件描述符数量不受限制。

### epoll

epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。

* 如何解决性能开销大？
    1. 为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表。通过判断就绪列表是否有值，这样时间复杂度就变成了O(1)，select和poll的需要遍历所有的文件描述符集合，时间复杂度是O(n)

    2. 每次调用 select 时都需要向内核拷贝所有要监听的描述符集合，而 epoll 对于每个描述符，只需要在传递一次，之后不需要再次传递。这也大大提高了效率。

* 如何解决文件描述符少？
epoll解决文件描述符数量少的问题，是采用红黑树来存储文件描述符集合。


### 使用场景：
* select ： 更加适用于实时要求更高的场景，因为超时时间可以到纳秒，epoll和poll是到毫秒。
 
* poll ：没有最大描述符数量的限制，如果对实时性要求不高，应该使用 poll 而不是 select，并且如果同时监控小于 1000 个描述符，就没有必要使用 epoll。
 
* epoll 如果只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。

### 水平触发和边缘触发
select，poll 只支持水平触发，epoll 支持水平触发和边缘触发。

水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。


</details>