# 数据库

   如需要展开全部,可以在网页控制台执行以下代码
   ```
   [...document.getElementById("readme").getElementsByTagName("details")].forEach(e => e.open = true)
   ```

* [MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？](#1)

* [数据库的事务隔离级别有哪些？各有哪些优缺点？](#2)

* [什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项？](#3)

* [简述脏读和幻读的发生场景，InnoDB 是如何解决快照读带来的幻读？](#4)

* [快照读和当前读是什么？InnoDB 是如何解决当前读带来的幻读？](#5)






------

### <span id="1">1.MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？</span>
<details>
<summary>展开</summary>

##### 数组
如果针对索引的操作只是精确查询或者范围查询的话，那么使用数组就够了，通过二分查找时间复杂度是O(logn)。但是如果还需要插入索引的话，那么因为数组的有序性，就需要O(n)的时间复杂度才能插入。

##### 二叉搜索树
由于数组O(n)的插入复杂度，所以可以考虑使用二叉搜索树，这样查询、插入等操作的时间复杂度就都是O(logn),也就是需要操作 logn次的 I/O 操作取出数据。
但是二叉搜索树有一个问题，就是范围查询很慢，需要不断的从根节点出发，进行搜索，所以可以进行优化数据只保存在叶子节点上，并使用双向链表连接，这样就不用每次都从根节点出发了。

##### B+树
又因为二叉搜索树在数据量大的时候，树的高度太高了，比如高为10的的BST，就需要10次 I/O 操作，所以继续优化的话，就是让树变的矮胖，减少I/O次数，就变成“多叉搜索树”。这个就是B+ Tree.

B Tree 和 B+ Tree都是多叉搜索树，但是两者有以下几个区别：
1. B树的节点即保存数据也保存索引，而B+树只有叶子节点保存索引和数据，其余节点只保存索引。
2. 范围查询：B树进行范围查询的时候，只能通过父节点和子节点进行连接，那么就必须不断回溯，会产生很多I/O操作。而B+ 树因为叶子节点之间通过双向链表连接，可以使用前后指针就可以查出所有数据。
3. B+树的检索效率稳定，任何查找都是从根节点到叶子节点的过程。


</details>

------

### <span id="2">2.数据库的事务隔离级别有哪些？各有哪些优缺点？</span>
<details>
<summary>展开</summary>

事务的隔离级别对应的隔离性，属于数据库事务ACID中的I。

事务隔离级别要解决的问题：
* 脏读：指的是读到了其他事务未提交的数据，未提交代表可能回滚，也就是读到了并一定最终存在的数据。
* 不可重复读：指的是在同一事物中，不同时刻读到的同一批数据可能不一样，受到其他事物的影响，通常针对UPDATE操作。
* 幻读：指的的是在同一事务中，同一个范围内的记录被读取时，其他事务向这个范围添加了新的记录。通常针对INSERT操作。

MYSQL事物的隔离级别为：
* 读未提交（RU）：可能出现 脏读、不可重复读、幻读
* 读已提交（RC）：可能出现 不可重复读、幻读
* 可重复读（RR）：可能出现 幻读
* 串行化：不会出现 脏读、不可重复读、幻读

事务隔离级别中 读未提交效率最高，因为不涉及加锁，而串行化效率最低，因为所有语句都是串行执行。

</details>


------

### <span id="3">3.什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项？</span>
<details>
<summary>展开</summary>

数据库事务指的 ACID 四大特性，包括以下：
* 原子性：事务就是一系列的操作，要么全部都执行，要么全都不执行。
* 一致性：是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。

* 隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
* 持久性：一旦事务被提交，数据一定会被写入到数据库中并持久存储起来。

在MySQL中，使用undo log日志实现原子性。使用重做日志（redo log）实现事务的持久性。
Mysql中事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。所以默认的引擎是innodb。

 </details>



------

### <span id="4">4.简述脏读和幻读的发生场景，InnoDB 是如何解决快照读带来的幻读？</span>
<details>
<summary>展开</summary>

* 脏读：读到了其他事务未提交的数据，未提交代表可能回滚，也就是读到了并一定最终存在的数据。
* 不可重复读：指的是在同一事物中，不同时刻读到的同一批数据可能不一样，受到其他事物的影响，通常针对UPDATE操作。
* 幻读：指的的是在同一事务中，同一个范围内的记录被读取时，其他事务向这个范围添加了新的记录。通常针对INSERT操作。


在InnoDB中的事务隔离级别，读已提交解决了脏读，不可重复读解决了脏读、不可重复读、幻读。在MySQL中读已提交和不可重复读的隔离级别都是基于MVCC快照实现的，具体就是采用了基于undo log版本链实现的ReadView机制给事务打快照。

### ReadView实现
ReadView机制就是将当时事务状态记下来，之后的所有读操作根据其事务ID（即trx_id）与快照中的事务的状态作比较，以此判断ReadView对于事务的可见性。

ReadView中保存的事务状态主要包括：
* m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表，也就是有哪些事务在MySQL里执行还没提交的。

* min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
* max_trx_id：表示生成ReadView时系统中下一个要生成的事务id。（注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。假设现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。）

* creator_trx_id：表示生成该ReadView的事务的事务id，也就是当前的事务ID。

判断规则：有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：
* 如果被访问版本的trx_id = ReadView中的creator_trx_id ，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。

* 如果被访问版本的trx_id < ReadView中的min_trx_id，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。

* 如果被访问版本的trx_id >= ReadView中的max_trx_id，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。

* 如果被访问版本的trx_id在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中。
    * 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；
    * 如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

总结上述规则，就是：
1. 当前事务内的更新，可以读到；
2. 版本未提交，不能读到；
3. 版本已提交，但是却在快照创建后提交的，不能读到；
4. 版本已提交，且是在快照创建前提交的，可以读到；

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。


读已提交(RC)实现原理 :每次读取数据前都生成一个ReadView
可重复读(RR)实现原理 :在第一次读取数据时生成一个ReadView
 
</details>



------

### <span id="5">5.快照读和当前读是什么？InnoDB 是如何解决当前读带来的幻读？</span>
<details>
<summary>展开</summary>

快照读：在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，这就是快照读。
当前读：读到的都是数据库最新的数据。

快照读：就是select
* select * from table ….;

当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
* select * from table where ? lock in share mode;
* select * from table where ? for update;
* insert;
* update ;
* delete;

为什么要强调快照读和当前读呢？因为在MySQL官方认为连续的快照读或者连续的当前读出现数据不一致才符合幻读的定义。

快照读：使用MVCC解决幻读。
当前读：使用next-key，结合了索引行锁和间隙锁来解决幻读。

情况1：事务A开启了一个事务后，进行了两次select，这个时候都是使用快照读，那么通过结果我们可以看出确实没有查出修改后的数据，这说明RR级别下，避免了**不可重复读**问题。

| 事务A | 事务B |
| --- | --- |
| BEGIN; | BEGIN; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
|  | UPDATE `user` set nick_name = 'bb' where id = 13; |
|  | COMMIT; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
| COMMIT; |  |

情况2：事务A开启了一个事务后，进行了两次select，这个时候都是使用快照读，那么通过结果我们可以看出确实没有查出修改后的数据，这说明InnoDB下RR级别下快照读，避免了**幻读**问题。

| 事务A | 事务B |
| --- | --- |
| BEGIN; | BEGIN; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
|  | INSERT INTO `user` (`id`,`nick_name`, ) VALUES (15, 'cc', ); |
|  | COMMIT; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' ROW=1 |  |
| COMMIT; |  |

情况3：事务A开启了一个时候后，进行了一次select,进行了一次update,这个时候select使用快照读,而update则使用当前读，那么这种情况（「快照读」和「当前读」一起使用）下就会出现**幻读**。

| 事务A | 事务B |
| --- | --- |
| BEGIN; | BEGIN; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
|  | INSERT INTO `user` (`id`,`nick_name`, ) VALUES (15, 'cc', ); |
|  | COMMIT; |
|  update `user` set nick_name = 'dd’ ; 结果：Affected rows: 2|  |
| SELECT * from `user`; 结果：id=13 nick_name = ‘aa’ id = 15 nick_name = 15 |  |
| COMMIT; |  |

情况4：针对上面的情况，我们调整下代码，将事务B的插入放在事务UPDATE后面，那么这种情况就没有发生幻读，这是因为当前读加了加 next-key lock，这样事务B就会一直阻塞到事务A提交。

| 事务A | 事务B |
| --- | --- |
| BEGIN; |  |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
| update user set nick_name = 'dd’ ; 结果：Affected rows: 1 |  |
|  | BEGIN; |
|  | INSERT INTO user (id,nick_name, ) VALUES (15, 'cc', ); |
| SELECT * from `user`; 结果：id=13 nick_name = ‘dd’  | Wait  |
| COMMIT; |  |
|  | COMMIT; |

情况5：上面情况说的是当前读加了Next-Key锁，我们也可以自己手动给select加next-key锁，这样也不会出现幻读；

| 事务A | 事务B |
| --- | --- |
| BEGIN; |  |
| SELECT * from `user` for update; 结果：id=13 nick_name == ‘aa' |  |
|  | BEGIN; |
|  | INSERT INTO user (id,nick_name, ) VALUES (15, 'cc', );  |
| SELECT * from `user`; 结果：id=13 nick_name = ‘aa’  | Wait |
| COMMIT; |  |
|  | COMMIT; |

总结一下：快照读的时候无需任何操作即可避免幻读，当快照读和当前读混合使用的使用就需要按照实际情况显式加锁去解决幻读或者按照规范使用next-key来解决。




</details>