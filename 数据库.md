# 数据库

   如需要展开全部,可以在网页控制台执行以下代码
   ```
   [...document.getElementById("readme").getElementsByTagName("details")].forEach(e => e.open = true)
   ```

* [MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？](#1)

* [数据库的事务隔离级别有哪些？各有哪些优缺点？](#2)

* [什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项？](#3)

* [简述脏读和幻读的发生场景，InnoDB 是如何解决快照读带来的幻读？](#4)

* [快照读和当前读是什么？InnoDB 是如何解决当前读带来的幻读？](#5)

* [简述 MySQL 的锁？](#6)

* [简述乐观锁以及悲观锁的区别以及使用场景？](#7)

* [什么情况下会发生死锁，如何解决死锁？](#8)



聚簇索引和非聚簇索引有什么区别？
唯一索引与普通索引的区别是什么？使用索引会有哪些优缺点？
MySQL 的索引什么情况下会失效？
数据库如何设计索引，如何优化查询？
假设建立联合索引 (a, b, c) 如果对字段 a 和 c 查询，会用到这个联合索引吗？
什么是 SQL 注入攻击？如何防止这类攻击？
简述 MySQL 的主从同步机制，如果同步失败会怎么样？
MySQL 有什么调优的方式？
MySQL 有哪些常见的存储引擎？它们的区别是什么？






------

### <span id="1">1.MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？</span>
<details>
<summary>展开</summary>

##### 数组
如果针对索引的操作只是精确查询或者范围查询的话，那么使用数组就够了，通过二分查找时间复杂度是O(logn)。但是如果还需要插入索引的话，那么因为数组的有序性，就需要O(n)的时间复杂度才能插入。

##### 二叉搜索树
由于数组O(n)的插入复杂度，所以可以考虑使用二叉搜索树，这样查询、插入等操作的时间复杂度就都是O(logn),也就是需要操作 logn次的 I/O 操作取出数据。
但是二叉搜索树有一个问题，就是范围查询很慢，需要不断的从根节点出发，进行搜索，所以可以进行优化数据只保存在叶子节点上，并使用双向链表连接，这样就不用每次都从根节点出发了。

##### B+树
又因为二叉搜索树在数据量大的时候，树的高度太高了，比如高为10的的BST，就需要10次 I/O 操作，所以继续优化的话，就是让树变的矮胖，减少I/O次数，就变成“多叉搜索树”。这个就是B+ Tree.

B Tree 和 B+ Tree都是多叉搜索树，但是两者有以下几个区别：
1. B树的节点即保存数据也保存索引，而B+树只有叶子节点保存索引和数据，其余节点只保存索引。
2. 范围查询：B树进行范围查询的时候，只能通过父节点和子节点进行连接，那么就必须不断回溯，会产生很多I/O操作。而B+ 树因为叶子节点之间通过双向链表连接，可以使用前后指针就可以查出所有数据。
3. B+树的检索效率稳定，任何查找都是从根节点到叶子节点的过程。


</details>

------

### <span id="2">2.数据库的事务隔离级别有哪些？各有哪些优缺点？</span>
<details>
<summary>展开</summary>

事务的隔离级别对应的隔离性，属于数据库事务ACID中的I。

事务隔离级别要解决的问题：
* 脏读：指的是读到了其他事务未提交的数据，未提交代表可能回滚，也就是读到了并一定最终存在的数据。
* 不可重复读：指的是在同一事物中，不同时刻读到的同一批数据可能不一样，受到其他事物的影响，通常针对UPDATE操作。
* 幻读：指的的是在同一事务中，同一个范围内的记录被读取时，其他事务向这个范围添加了新的记录。通常针对INSERT操作。

MYSQL事物的隔离级别为：
* 读未提交（RU）：可能出现 脏读、不可重复读、幻读
* 读已提交（RC）：可能出现 不可重复读、幻读
* 可重复读（RR）：可能出现 幻读
* 串行化：不会出现 脏读、不可重复读、幻读

事务隔离级别中 读未提交效率最高，因为不涉及加锁，而串行化效率最低，因为所有语句都是串行执行。

</details>


------

### <span id="3">3.什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项？</span>
<details>
<summary>展开</summary>

数据库事务指的 ACID 四大特性，包括以下：
* 原子性：事务就是一系列的操作，要么全部都执行，要么全都不执行。
* 一致性：是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。

* 隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
* 持久性：一旦事务被提交，数据一定会被写入到数据库中并持久存储起来。

在MySQL中，使用undo log日志实现原子性。使用重做日志（redo log）实现事务的持久性。
Mysql中事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。所以默认的引擎是innodb。

 </details>



------

### <span id="4">4.简述脏读和幻读的发生场景，InnoDB 是如何解决快照读带来的幻读？</span>
<details>
<summary>展开</summary>

* 脏读：读到了其他事务未提交的数据，未提交代表可能回滚，也就是读到了并一定最终存在的数据。
* 不可重复读：指的是在同一事物中，不同时刻读到的同一批数据可能不一样，受到其他事物的影响，通常针对UPDATE操作。
* 幻读：指的的是在同一事务中，同一个范围内的记录被读取时，其他事务向这个范围添加了新的记录。通常针对INSERT操作。


在InnoDB中的事务隔离级别，读已提交解决了脏读，不可重复读解决了脏读、不可重复读、幻读。在MySQL中读已提交和不可重复读的隔离级别都是基于MVCC快照实现的，具体就是采用了基于undo log版本链实现的ReadView机制给事务打快照。

### ReadView实现
ReadView机制就是将当时事务状态记下来，之后的所有读操作根据其事务ID（即trx_id）与快照中的事务的状态作比较，以此判断ReadView对于事务的可见性。

ReadView中保存的事务状态主要包括：
* m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表，也就是有哪些事务在MySQL里执行还没提交的。

* min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
* max_trx_id：表示生成ReadView时系统中下一个要生成的事务id。（注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。假设现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。）

* creator_trx_id：表示生成该ReadView的事务的事务id，也就是当前的事务ID。

判断规则：有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：
* 如果被访问版本的trx_id = ReadView中的creator_trx_id ，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。

* 如果被访问版本的trx_id < ReadView中的min_trx_id，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。

* 如果被访问版本的trx_id >= ReadView中的max_trx_id，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。

* 如果被访问版本的trx_id在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中。
    * 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；
    * 如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

总结上述规则，就是：
1. 当前事务内的更新，可以读到；
2. 版本未提交，不能读到；
3. 版本已提交，但是却在快照创建后提交的，不能读到；
4. 版本已提交，且是在快照创建前提交的，可以读到；

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。


读已提交(RC)实现原理 :每次读取数据前都生成一个ReadView
可重复读(RR)实现原理 :在第一次读取数据时生成一个ReadView
 
</details>



------

### <span id="5">5.快照读和当前读是什么？InnoDB 是如何解决当前读带来的幻读？</span>
<details>
<summary>展开</summary>

快照读：在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，这就是快照读。
当前读：读到的都是数据库最新的数据。

快照读：就是select
* select * from table ….;

当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
* select * from table where ? lock in share mode;
* select * from table where ? for update;
* insert;
* update ;
* delete;

为什么要强调快照读和当前读呢？因为在MySQL官方认为连续的快照读或者连续的当前读出现数据不一致才符合幻读的定义。

快照读：使用MVCC解决幻读。
当前读：使用next-key，结合了索引行锁和间隙锁来解决幻读。

情况1：事务A开启了一个事务后，进行了两次select，这个时候都是使用快照读，那么通过结果我们可以看出确实没有查出修改后的数据，这说明RR级别下，避免了**不可重复读**问题。

| 事务A | 事务B |
| --- | --- |
| BEGIN; | BEGIN; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
|  | UPDATE `user` set nick_name = 'bb' where id = 13; |
|  | COMMIT; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
| COMMIT; |  |

情况2：事务A开启了一个事务后，进行了两次select，这个时候都是使用快照读，那么通过结果我们可以看出确实没有查出修改后的数据，这说明InnoDB下RR级别下快照读，避免了**幻读**问题。

| 事务A | 事务B |
| --- | --- |
| BEGIN; | BEGIN; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
|  | INSERT INTO `user` (`id`,`nick_name`, ) VALUES (15, 'cc', ); |
|  | COMMIT; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' ROW=1 |  |
| COMMIT; |  |

情况3：事务A开启了一个时候后，进行了一次select,进行了一次update,这个时候select使用快照读,而update则使用当前读，那么这种情况（「快照读」和「当前读」一起使用）下就会出现**幻读**。

| 事务A | 事务B |
| --- | --- |
| BEGIN; | BEGIN; |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
|  | INSERT INTO `user` (`id`,`nick_name`, ) VALUES (15, 'cc', ); |
|  | COMMIT; |
|  update `user` set nick_name = 'dd’ ; 结果：Affected rows: 2|  |
| SELECT * from `user`; 结果：id=13 nick_name = ‘aa’ id = 15 nick_name = 15 |  |
| COMMIT; |  |

情况4：针对上面的情况，我们调整下代码，将事务B的插入放在事务UPDATE后面，那么这种情况就没有发生幻读，这是因为当前读加了加 next-key lock，这样事务B就会一直阻塞到事务A提交。

| 事务A | 事务B |
| --- | --- |
| BEGIN; |  |
| SELECT * from `user`; 结果：id=13 nick_name == ‘aa' |  |
| update user set nick_name = 'dd’ ; 结果：Affected rows: 1 |  |
|  | BEGIN; |
|  | INSERT INTO user (id,nick_name, ) VALUES (15, 'cc', ); |
| SELECT * from `user`; 结果：id=13 nick_name = ‘dd’  | Wait  |
| COMMIT; |  |
|  | COMMIT; |

情况5：上面情况说的是当前读加了Next-Key锁，我们也可以自己手动给select加next-key锁，这样也不会出现幻读；

| 事务A | 事务B |
| --- | --- |
| BEGIN; |  |
| SELECT * from `user` for update; 结果：id=13 nick_name == ‘aa' |  |
|  | BEGIN; |
|  | INSERT INTO user (id,nick_name, ) VALUES (15, 'cc', );  |
| SELECT * from `user`; 结果：id=13 nick_name = ‘aa’  | Wait |
| COMMIT; |  |
|  | COMMIT; |

总结一下：快照读的时候无需任何操作即可避免幻读，当快照读和当前读混合使用的使用就需要按照实际情况显式加锁去解决幻读或者按照规范使用next-key来解决。




</details>



------

### <span id="6">6.简述 MySQL 的锁？</span>
<details>
<summary>展开</summary>


InnoDB中关于锁的种类分为两类：
1. 共享锁（Shared Lock）S：读锁
2. 互斥锁（Exclusive Lock）X：写锁

![](https://github.com/binbinshan/Review-Up/blob/master/images/数据库/16246107884819.jpg)

共享锁代表了读操作、互斥锁代表了写操作，所以我们可以在数据库中并行读，但是只能串行写，只有这样才能保证不会发生线程竞争，实现线程安全。


共享锁还是互斥锁其实都只是对某一个数据行进行加锁，InnoDB 支持多种粒度的锁，也就是行锁和表锁；为了支持多粒度锁定，InnoDB 存储引擎引入了意向锁（Intention Lock），意向锁就是一种表级锁。
* 意向共享锁：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；
* 意向互斥锁：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；

如果没有意向锁，当已经使用行锁对表中的某一行进行加锁，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；
在引入意向锁之后，当使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有别的事务尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。


### 锁的算法
在MySQL中，有三种锁的实现：
1. Record Lock：记录锁，是加到索引记录上的锁。当通过聚簇索引或二级索引查找时，会在索引上加Record Lock，如果不是索引的话，就会给整张表加锁。
2. Gap Lock：间隙锁，是索引记录之间上的锁。间隙锁是性能与并发的部分折中，并只适用于一些事务隔离级别。例如，SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE; 就会阻止其他事务插入 c1 = 15 的记录

3. Next-Key Lock：下一键锁，是记录锁和记录前的间隙锁的结合，是一个索引记录锁加上一个在索引记录之前的间隙上的间隙锁。

    ```
    +------|-------------|--------------|-------+
    |   id | last_name   | first_name   |   age |
    |------|-------------|--------------|-------|
    |    4 | stark       | tony         |    21 |
    |    1 | tom         | hiddleston   |    30 |
    |    3 | morgan      | freeman      |    40 |
    |    5 | jeff        | dean         |    50 |
    |    2 | donald      | trump        |    80 |
    +------|-------------|--------------|-------+
    
    如果使用 Next-Key 锁，那么 Next-Key 锁就可以在需要的时候锁定以下的范围：
    (-∞, 21]
    (21, 30]
    (30, 40]
    (40, 50]
    (50, 80]
    (80, ∞)
    
    Next-Key 锁锁定的是当前值和前面的范围。
    ```


    比如 SELECT * FROM users WHERE age = 30 FOR UPDATE; InnoDB 不仅会在范围 (21, 30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30, 40] 加间隙锁，所以插入 (21, 40] 范围内的记录都会被锁定。


</details>


------

### <span id="7">7.简述乐观锁以及悲观锁的区别以及使用场景？</span>
<details>
<summary>展开</summary>

锁的种类一般分为乐观锁和悲观锁，而在innoDB中使用的就是悲观锁。而按照锁的粒度划分，也可以分成行锁和表锁。

乐观锁和悲观锁其实都是并发控制的机制，同时它们在原理上就有着本质的差别；
* 乐观锁是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁；

* 悲观锁就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；

乐观锁不会存在死锁的问题，但是由于更新后验证，所以当冲突频率和重试成本较高时更推荐使用悲观锁，而需要非常高的响应速度并且并发量非常大的时候使用乐观锁就能较好的解决问题。

</details>


------

### <span id="8">8.什么情况下会发生死锁，如何解决死锁？</span>
<details>
<summary>展开</summary>


A事务中：
```
//加了 s 锁
SELECT * FROM t WHERE i = 1 FOR SHARE;
```
B事务中：
```
//会加上 x 锁
DELETE FROM t WHERE i = 1;
```
此时B事务会等待A事务提交，因为s锁和x锁是互斥的。

A事务中又执行了：
```
DELETE FROM t WHERE i = 1;
//此时会返回错误信息：
Deadlock found when trying to get lock; 试图锁定时发现死锁;
```

A先加了共享锁，B加了排他锁，A又加了排他锁。

##### 死锁检测
死锁检测是一个MySQL Server层的自动检测机制，可以及时发现两个或者多个session间互斥资源的申请造成的死锁，且会自动回滚一个（或多个）事物代价相对较小的session，让执行代价最大的先执行。该参数默认就是打开的。

如果关闭了死锁检测机制，会根据innodb_lock_wait_timeout，该参数指定了“锁申请时候的最长等待时间”，当发生锁等待超时时，回滚当前语句 （不是整个事务）。

##### 死锁优化
1. 减少代码层面并发
2. 减少大事务的出现
3. 减少锁时间长的在事务前面


</details>


